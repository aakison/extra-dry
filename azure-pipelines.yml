
# ASP.NET Core
# Build and test ASP.NET Core projects targeting .NET Core.
# Add steps that run tests, create a NuGet package, deploy, and more:
# https://docs.microsoft.com/azure/devops/pipelines/languages/dotnet-core
# Packages ExtraDry for NuGet and builds sample application.

trigger:
- main
- release
- develop

pool:
  vmImage: 'windows-latest'

variables:
  buildConfiguration: 'Release'
  # Version details for `dotnet pack`, values to be overwritten by `GitSemVer`.
  majorVersion: 0
  minorVersion: 1
  patchVersion: 0
  prereleaseVersion: ''
  semanticVersion: '0.1.0'  
  nugetProjectsGlob: '**/ExtraDry.+(Core|Server|Blazor|Swashbuckle|Core.Abstractions).csproj' # don't build samples
  sampleProjectsGlob: '**/Sample.Server.csproj'
  testsGlob: '**/ExtraDry.+(Core|Server|Blazor).Tests.csproj'
  isForDeployment: $[in(variables['Build.SourceBranch'], 'refs/heads/main', 'refs/heads/develop', 'refs/heads/release')]

steps:
- task: UseDotNet@2
  displayName: 'Install .NET 7.0 SDK'
  inputs:
    version: '7.0.x'

- task: DotNetCoreCLI@2
  displayName: Install Entity Framework
  inputs:
    command: 'custom'
    custom: 'tool'
    arguments: 'install --global dotnet-ef'

- task: DotNetCoreCLI@2
  displayName: Restore
  inputs:
    command: restore
    projects: '**/*.csproj'
    verbosityRestore: normal
    feedsToUse: config
    nugetConfigPath: ./ExtraDry/nuget.config

- task: PowerShell@2
  name: CheckVulnerability
  displayName: 'Check NuGet Packages for Vulnerabilities'
  inputs:
    targetType: 'inline'
    script: |
      $global:failedLines = 0;
      Function Scan-Line-For-Vulnerability {
        [CmdletBinding()]
        Param([Parameter(ValueFromPipeline)] $line)
        process {
          Write-Host $line
          if($line.Contains("Moderate") -OR $line.Contains("High")) {
            $global:failedLines = $global:failedLines + 1
          }
        }
      }
      dotnet list .\ExtraDry package --vulnerable --include-transitive | Scan-Line-For-Vulnerability
      if($global:failedLines) {
        Write-Host
        Write-Host "Vulnerabilities in dependant package have been found, please upgrade or replace." -ForegroundColor Red
        exit 1
      }

- task: PowerShell@2
  name: GitSemVer
  displayName: 'Evaluate Git Semantic Version'
  inputs:
    targetType: 'inline'
    script: |
      Write-Host "Trigger Branch is $Env:BUILD_SOURCEBRANCHNAME"
      function HeadIsBranch($branch) {
        if($Env:BUILD_SOURCEBRANCHNAME -eq $null) {
          $headHash = git rev-parse HEAD
          $branchHash = git rev-parse $branch
          $headHash -eq $branchHash
        }
        else {
          $Env:BUILD_SOURCEBRANCHNAME -eq $branch
        }
      }
      function PublishVariable($name, $value) {
        Write-Host "Setting Variable $name to: $value"
        Write-Host "##vso[task.setvariable variable=$name]$value"
      }
      function Coallesce($value1, $value2) {
        if($value1 -eq $null) { $value2 } else { $value1 }
      }
      $describe = git describe --tags
      Write-Host "Git Version is $describe"
      $bits = $describe.TrimStart("v").Split(".-")
      $majorVersion = Coallesce $bits[0] 1
      $minorVersion = Coallesce $bits[1] 0
      $patchVersion = Coallesce $bits[2] 0
      $prereleaseVersion = "head" # no semantic meaning
      if(HeadIsBranch("develop")) {
          $prereleaseVersion = "alpha"
      }
      if(HeadIsBranch("release")) {
          $prereleaseVersion = "beta"
      }
      if(HeadIsBranch("main") -OR HeadIsBranch("master")) {
          $prereleaseVersion = ""
      }
      $semanticVersion = "$majorVersion.$minorVersion.$patchVersion-$prereleaseVersion".TrimEnd("-")
      PublishVariable "majorVersion" $majorVersion
      PublishVariable "minorVersion" $minorVersion
      PublishVariable "patchVersion" $patchVersion
      PublishVariable "prereleaseVersion" $prereleaseVersion
      PublishVariable "semanticVersion" $semanticVersion

- task: DotNetCoreCLI@2
  displayName: Build Projects
  inputs:
    command: build
    projects: '**/*.csproj'
    arguments: '--configuration $(BuildConfiguration) /p:Version=$(semanticVersion) /p:InformationalVersion=$(semanticVersion) --no-restore'

- task: DotNetCoreCLI@2
  displayName: Run Unit Tests
  inputs:
    command: test
    projects: '**/*.Tests.csproj'
    arguments: '--configuration $(BuildConfiguration) --collect "Code coverage" --no-build'
    nobuild: true

- task: DotNetCoreCLI@2
  displayName: 'Publish Migration Script'
  inputs:
    command: 'custom'
    custom: 'ef'
    arguments: 'migrations script --project $(build.sourcesdirectory)/ExtraDry/Sample.Data/Sample.Data.csproj --idempotent --verbose --output $(build.artifactstagingdirectory)\sample\sql\migrations.sql'

- task: DotNetCoreCLI@2
  displayName: 'Publish Web App'
  inputs:
    command: publish
    publishWebProjects: false
    projects: $(sampleProjectsGlob)
    arguments: '--configuration $(BuildConfiguration) --no-build --output $(build.artifactstagingdirectory)\sample'
    zipAfterPublish: false
    modifyOutputPath: false

- task: DotNetCoreCLI@2
  displayName: 'Publish Web Jobs'
  inputs:
    command: publish
    publishWebProjects: false
    projects: '**/Sample.WebJobs.csproj'
    arguments: '--configuration $(BuildConfiguration) --no-build --output $(build.artifactstagingdirectory)\sample\App_Data\jobs\continuous'
    zipAfterPublish: false

- task: DotNetCoreCLI@2
  displayName: Pack NuGet Packages
  condition: and(succeeded(), eq(variables.isForDeployment, true))
  inputs:
    command: 'pack'
    packagesToPack: $(nugetProjectsGlob)
    versioningScheme: 'byEnvVar'
    versionEnvVar: 'semanticVersion'
    packDirectory: '$(Build.ArtifactStagingDirectory)\packages'
    nobuild: true

- task: PublishBuildArtifacts@1
  displayName: 'Publish NuGet Artifacts'
  condition: and(succeeded(), eq(variables.isForDeployment, true))
  inputs:
    PathtoPublish: '$(build.artifactstagingdirectory)\packages'
    artifactName: NuGetPackages

- task: PublishBuildArtifacts@1
  displayName: 'Publish Sample Artifact'
  condition: and(succeeded(), eq(variables.isForDeployment, true))
  inputs:
    PathtoPublish: '$(build.artifactstagingdirectory)\sample'
    artifactName: SampleApp
